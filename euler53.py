## Q53
## 조합 Combination을 nCr로 표현할 때 1 <= n <= 100 중 백만이 넘는 수의 개수
## 계산을 줄이기 위해 고등학교때 배웠던 조합 빠르게 푸는 방법을 함수로 만들었다.
## ex) 5C3이면 원래는 5!/(2!*3!) 을 계산하여야 하는데 (5*4*3)/(3*2*1) 이렇게 계산하도록
## 또한 조합은 대칭이기때문에 백만을 넘기 시작하면 중간을 기준으로 갯수를 세고 *2 한 후 다음 n으로 넘어가는 알고리즘을 짰다.

start = time.time()

def Fac_n_r(n, r):                              ## 조합 계산의 분자 부분
    a = 1
    for i in range(n, n-r, -1):
        a *= i
    return a

def Fac_r(r):                                   ## 조합 계산의 분모 부분
    a = 1
    for i in range(r, 0, -1):
        a *= i
    return a

n = 2                                           ## 1은 하나마나라서 2부터
r = 1
cnt = 0
while n <= 100:                                 ## n이 100이하
    if Fac_n_r(n, r)// Fac_r(r) >= 1e6:         ## 백만을 넘어가면
        if n % 2 == 0:                          ## n이 짝수랑 홀수일 때로 나눠서 cnt 추가
            cnt += ((n // 2) - r) * 2 + 1       ## 대충 계산해보니까 이렇게 나온다.
            n += 1                              ## 다음 n으로 넘어간다.
            r = 0                               ## r은 0부터 다시

        else:                                   ## 홀수일 때
            cnt += (((n // 2) + 1) - r) * 2     ## 대충 공책으로 계산
            n += 1
            r = 0
    if (n // 2) == r:                           ## r이 n의 반이면 즉 대칭하는 과정에 있으면
        n += 1                                  ## 다음 n으로 넘어간다.
        r = 0
    r += 1                                      ## 아무것도 아니면 r += 1

end = time.time() - start

print(cnt, end)     ## 4075 0.001338958740234375

## 너무 빨리 나와서 아주 raw하게 만들어서 시간을 재 봤다.

start = time.time()

n = 2
r = 1
cnt = 0
while n <= 100:
    if Fac_r(n) // (Fac_r(r) * Fac_r(n - r)) >= 1e6:
        cnt += 1
    if n == r:
        n += 1
        r = 1
    else:
        r += 1

end = time.time() - start

print(cnt, end)     ## 4075 0.05929303169250488

## 별로 차이가 없었다.
## n이 작아서 그런가보다 하고 n을 높여보았다. 350정도부터 유의미한 차이가 나타나기 시작.